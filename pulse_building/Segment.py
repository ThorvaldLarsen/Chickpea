import numpy as np
import copy

# TODO: exceptions
# TODO: cut name?
# TODO: unbound and bound markers coexisting happily?
# TODO: int vs round


class Segment:
    def __init__(self, name=None, gen_func=None, func_args=None,
                 points_array=None, points_markers=None,
                 time_markers=None, raw_markers=None):
        """
        Segment class which represents a segment of a wave and markers
        for one channel of the AWG at one point in time. These can be in
        the form of an explicit numpy array or generated by functions
        together with a sampling rate.
        ie one waveform has many segments

        Args:
            name (str): optional segment name
            gen_func(fn): optional function used to generate segment points,
                must have SR sample rate as a parameter
            func_args (dict): optional dict of arguments to go into the
                function alongside sample rate
            points_array (list or numpy array): optional alternative to have a
                segment generated by a function.
            points_markers (dict): optional dictionary of bound markers of the
                form {1: {'delay_points': [], 'duration_points': []}, 2: ...}
                (ie values in points rather than time)
            time_markers (dict): optional dictionary of bound markers
                of the form
                {1: {'delay_time': [], 'duration_time': []}, 2: ...}
            raw_markers (dict): optional dictionary of form {1: [], 2: []]}
                where the length of the marker lists must be 0 or the same as
                the specified points_array
        """

        # Check if there is a points array specified or a function specified
        # and takes the function name for naming the segment
        if points_array is not None:
            if gen_func is not None:
                raise Exception('cannot set both gen_func for points '
                                'generation and points_array')
            elif not isinstance(points_array, (list, np.ndarray)):
                raise TypeError('points_array must be a list or numpy array')
        else:
            if (gen_func is not None) and (name is None):
                name = gen_func.__name__

        # Check marker dictionaties have valid keys, that if a marker is
        # specified it is not duplicated across dictionaries and that any
        # raw markers  are of the same length as the specified points array.
        if time_markers is None:
            time_markers = {}
            time_marker_nums = []
        else:
            time_marker_nums = time_markers.keys()
            if not all([k in [1, 2] for k in time_markers.keys()]):
                raise Exception('time_markers dict must have keys in [1, 2]'
                                ' {} received'.format(time_markers.keys()))
            for m in time_marker_nums:
                if not all([k in time_markers[m].keys()
                            for k in ['delay_time', 'duration_time']]):
                    raise Exception('time_markers[{}] must have keys '
                                    '[\'delay_time\', \'duration_time\'], '
                                    'received: {}'.format(
                                        m, time_markers[m].keys()))
                if any(type(val) is not list
                       for val in time_markers[m].values()):
                    raise Exception('time markers must be set as a list of '
                                    'delays and durations')

        if points_markers is None:
            points_markers = {}
            points_marker_nums = []
        else:
            points_marker_nums = points_markers.keys()
            if not all([k in [1, 2] for k in points_markers.keys()]):
                raise Exception('points_markers dict must have keys in [1, 2]'
                                ' {} received'.format(points_markers.keys()))
            for m in points_marker_nums:
                if not all([k in points_markers[m].keys()
                            for k in ['delay_points', 'duration_points']]):
                    raise Exception('points_markers[{}] must have keys '
                                    '[\'delay_points\', '
                                    '\'duration_points\'], received'
                                    ': {}'.format(m,
                                                  points_markers[m].keys()))
                if any(type(val) is not list
                       for val in points_markers[m].values()):
                    raise Exception('points markers must be set as a list of '
                                    'delays and durations')

        if raw_markers is None:
            raw_markers = {}
            raw_marker_nums = []
        else:
            raw_marker_nums = raw_markers.keys()
            if not all([k in [1, 2] for k in raw_markers.keys()]):
                raise Exception('raw_markers dict must have keys in [1, 2]'
                                ' {} received'.format(raw_markers.keys()))
            for m in raw_marker_nums:
                if not isinstance(raw_markers[m], (list, np.ndarray)):
                    raise TypeError('raw_markers[{}] must be a list or numpy '
                                    'array'.format(m))
                elif points_array is None:
                    raise Exception('must set points_array to set raw_markers')
                elif len(raw_markers[m]) != len(points_array):
                    raise Exception('raw_markers[{}] length {} not equal to '
                                    'points_array length {}'.format(
                                        m,
                                        len(raw_markers[m]),
                                        len(points_array)))
            points_markers.update(self._raw_to_points(raw_markers))

        overlap = set.intersection(set(time_marker_nums),
                                   set(points_marker_nums),
                                   set(raw_marker_nums))
        if overlap:
            raise Exception('you have tried to set a value for marker(s) {} '
                            'in more than one of the dictionaries: '
                            'time_markers, points_markers,'
                            ' raw_markers'.format(overlap))

        self.name = name
        self.func = gen_func
        self.func_args = func_args
        self._points = points_array
        self._points_markers = points_markers
        self._time_markers = time_markers

    def __iter__(self):
        return iter(self.points)

    def __len__(self):
        return len(self.points)

    def __repr__(self):
        return self.name

    def __format__(self, fmt):
        return str(self.name).__format__(fmt)

    def __add__(self, other):
        """
        Function for addition or concatenation of segments which returns
        a Segment object with
        name: 'seg1name_seg2name'
        gen_func: None
        func_args: {}
        points_array: np.array(seg1points, seg2points)
        points_markers: markers from both segments converted into delay and
            duration values in points
        time_markers: {}
        raw_markers: {}

        Args:
            other (Segment): second segment for addition

        Returns:
            sum  of segments (Segment)
        """
        if not isinstance(other, Segment):
            raise ValueError('Segment can only be added to another Segment.'
                             'Received object of type {}'.format(type(other)))

        new_name = self.name + '_' + other.name

        # If both sample rates were set this checks that they were the same
        # if ((self.sample_rate != other.sample_rate) or
        #         (self.sample_rate is None)):
        #     raise Exception('Both sample rates must be set and the same, '
        #                     'received sample rates: {}, {}.'.format(
        #                         self.sample_rate,
        #                         other.sample_rate))

        new_points = np.concatenate([self.points, other.points])

        new_markers = {1: {'delay_points': [], 'duration_points': []},
                       2: {'delay_points': [], 'duration_points': []}}

        if self._time_markers or other._time_markers:
            print('warning: time markers will be converted to point '
                  'markers so changes in sample rate will do '
                  'bad things')

        for m in [1, 2]:
            new_markers[m]['delay_points'].extend(
                self.markers[m]['delay_points'])
            for delay_point in other.markers[m]['delay_points']:
                new_markers[m]['delay_points'].append(
                    delay_point + len(self))
            new_markers[m]['duration_points'].extend(
                self.markers[m]['duration_points'])
            for duration_point in other.markers[m]['duration_points']:
                new_markers[m]['duration_points'].append(
                    duration_point)

        return Segment(name=new_name,
                       points_array=new_points,
                       points_markers=new_markers.copy())

    def copy(self):
        return copy.deepcopy(self)

    def _set_points(self, points_array):
        """
        Function which sets the points specifying the segment. The
        generator function is set to None and any unbound markers with
        a different length are cleared. Sample rate is also set to None
        and the function arguments dictionary cleared.

        Args:
            points_array (numpy array): points specifying the segment
        """
        if not isinstance(points_array, np.ndarray):
            raise AttributeError('points must be numpy array')
        for m in [1, 2]:
            if len(self._unbound_markers[m]) != len(points_array):
                del self._unbound_markers[m]
        self.func = None
        self.func_args.clear()
        self._points = points_array

    def _get_points(self):
        """
        Function which gets the points of a segment either by returning the
        array if specified or by evaluating the function with the given
        sample rate.

        Returns:
            points_array (numpy array): points specifying the segment
        """
        if self._points is not None:
            return self._points
        elif self.func is None:
            raise Exception('if points not set explicitly function must'
                            'be set to generate segment points')
        elif 'SR' not in self.func_args:
            raise Exception('sample rate not set so segment points cannot '
                            'be generated by function')
        else:
            return self.func(**self.func_args)

    points = property(fget=_get_points, fset=_set_points)

    def _get_duration(self):
        try:
            return len(self) / self.func_args['SR']
        except Exception:
            return None

    duration = property(fget=_get_duration)

    def _get_markers(self):
        """
        Function which returns a dictionary of marker delays and durations
        specified in points relative to the start of the segment points

        Returns:
            markers_dict of the form
                {1: {'delay_points': [], 'duration_points': []},
                 2: {'delay_points': [], 'duration_points': []}}
        """
        markers_dict = self._points_markers.copy()
        if self._time_markers:
            if 'SR' not in self.func_args:
                raise Exception('sample rate not set so bound '
                                'markers specified in time '
                                'cannot be calculated in points')
            markers_dict.update(self._time_to_points(self._time_markers,
                                                     self.func_args['SR']))
        for i in [1, 2]:
            if i not in markers_dict.keys():
                markers_dict[i] = {'delay_points': [], 'duration_points': []}
        return markers_dict

    markers = property(fget=_get_markers)

    def add_bound_markers(self, marker_num, delay, duration, time=False):
        """
        Function which adds a bound marker to a segment by updating the
        relevant marker dictionary with delay and duration values.

        Args:
            marker_num (1 or 2): marker to add to
            delay (float): point number (or time) of delay before marker starts
            duration (float): point number (or time) for which marker is on
            time (bool): whether or not values are in real time or in number
                of points(default False)
        """

        if not (marker_num in [1, 2]):
            raise Exception('marker_num be in [1, 2]: '
                            'received {}'.format(marker_num))

        if time:
            try:
                del self._points_markers[marker_num]
            except KeyError:
                pass
            try:
                self._time_markers[marker_num]['delay_time'].append(delay)
                self._time_markers[marker_num][
                    'duration_time'].append(duration)
            except KeyError:
                self._time_markers[marker_num] = {'delay_time': [delay],
                                                  'duration_time': [duration]}

        else:
            try:
                del self._time_markers[marker_num]
            except KeyError:
                pass
            try:
                self._points_markers[marker_num]['delay_points'].append(delay)
                self._points_markers[marker_num][
                    'duration_points'].append(duration)
            except KeyError:
                self._points_markers[marker_num] = {'delay_time': [delay],
                                                    'duration_time': [duration]}

    def add_raw_marker(self, marker_num, marker_array):
        """
        Function which adds a raw marker array to the segment by converting
        it into a delay-duration values in points

        Args:
            marker_num (1 or 2): marker to update
            marker_array (list or numpy array): list of 0s and 1s of the
                same length as the segmen specifying marker on/off state
        """
        if not (marker_num in [1, 2]):
            raise Exception('marker_num be in [1, 2]: '
                            'received {}'.format(marker_num))
        elif not isinstance(marker_array, (list, np.ndarray)):
            raise TypeError('marker_array must be numpy array')
        elif self._points is None:
            raise Exception('must set points to set raw_markers')
        elif len(marker_array) != len(self._points):
            raise Exception('marker_array length {} not equal to '
                            'points_array length {}'.format(
                                len(marker_array),
                                len(self._points)))
        elif any(int(v) not in [0, 1] for v in marker_array):
            raise AttributeError('marker values not in [0, 1]')
        try:
            del self._time_markers[marker_num]
        except KeyError:
            pass

        raw_marker = {marker_num: np.array(marker_array)}
        self._points_markers.update(self._raw_to_points(raw_marker))

    def clear_markers(self):
        """
        Function which clears marker dictionaries
        """
        self._points_markers.clear()
        self._time_markers.clear()

    @staticmethod
    def _raw_to_points(raw_markers):
        """
        Function which converts a dictionary of raw marker arrays into
        a dictionary of markers specified in duration and delay of marker
        'on' state

        Args:
            raw_marker (dict) of the form {1: [], 2: []}

        Returns:
            points_markers (dict) of the form
                {1: {'delay_points': [], 'duration_points'}...
        """
        points_markers = {}
        for m in np.array(raw_markers):
            points_markers[m] = {}
            nonzero_indices = np.nonzero(raw_markers[m])[0]
            starts = np.array([int(s) for s in nonzero_indices
                               if raw_markers[m][s - 1] != 1])
            ends = np.array([int(s) for s in nonzero_indices
                             if raw_markers[m][s + 1] != 1])
            marker_delays = starts
            marker_durations = ends - starts
            points_markers[m]['delay_points'] = marker_delays
            points_markers[m]['duration_points'] = marker_durations
        return points_markers

    @staticmethod
    def _time_to_points(time_markers, sample_rate):
        """
        Function which converts a dictionary of marker delays and durations
        in time into one specified in points

        Args:
            time_markers (dict) of the form
                {1: {'delay_time': [], 'duration_time': []}, 2: ...}
            sample_rate (float): points per second value

        Returns:
            points_markers (dict) of the form
                {1: {'delay_points': [], 'duration_points': []}, 2: ...}
        """
        points_markers = {}
        for m in time_markers:
            points_markers[m] = {}
            marker_delays = [int(d * sample_rate)
                             for d in time_markers[m]['delay_time']]
            marker_durations = [int(d * sample_rate)
                                for d in time_markers[m]['duration_time']]
            points_markers[m]['delay_points'] = marker_delays
            points_markers[m]['duration_points'] = marker_durations
        return points_markers
